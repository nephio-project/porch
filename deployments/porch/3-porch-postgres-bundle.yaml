# Copyright 2025 The kpt and Nephio Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: porch-postgresql
  namespace: porch-system
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: porch
    app.kubernetes.io/component: primary
spec:
  replicas: 1
  serviceName: porch-postgresql
  updateStrategy:
    rollingUpdate: {}
    type: RollingUpdate
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/instance: porch
      app.kubernetes.io/component: primary
  template:
    metadata:
      name: porch-postgresql
      labels:
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/instance: porch
        app.kubernetes.io/component: primary
    spec:
      affinity:
        podAffinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: postgresql
                    app.kubernetes.io/instance: porch
                    app.kubernetes.io/component: primary
                topologyKey: kubernetes.io/hostname
              weight: 1
        nodeAffinity:
      securityContext:
        fsGroup: 1001
      hostNetwork: false
      hostIPC: false
      containers:
        - name: postgresql
          image: docker.io/bitnamilegacy/postgresql:17.6.0-debian-12-r4
          imagePullPolicy: "IfNotPresent"
          securityContext:
            runAsUser: 1001
          env:
            - name: BITNAMI_DEBUG
              value: "false"
            - name: POSTGRESQL_VOLUME_DIR
              value: "/bitnami/postgresql"
            - name: PGDATA
              value: "/bitnami/postgresql/data"
            - name: POSTGRESQL_DATABASE
              valueFrom:
                configMapKeyRef:
                  name: porch-db-config
                  key: DB_NAME
            - name: POSTGRESQL_PORT_NUMBER
              valueFrom:
                configMapKeyRef:
                  name: porch-db-config
                  key: DB_PORT
            # Authentication
            - name: POSTGRESQL_USERNAME
              valueFrom:
                secretKeyRef:
                  name: porch-db-secret
                  key: DB_USER
            - name: POSTGRESQL_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: porch-db-secret
                  key: DB_PASSWORD
            # LDAP
            - name: POSTGRESQL_ENABLE_LDAP
              value: "no"
            # TLS
            - name: POSTGRESQL_ENABLE_TLS
              value: "no"
            # Audit
            - name: POSTGRESQL_LOG_HOSTNAME
              value: "false"
            - name: POSTGRESQL_LOG_CONNECTIONS
              value: "false"
            - name: POSTGRESQL_LOG_DISCONNECTIONS
              value: "false"
            - name: POSTGRESQL_PGAUDIT_LOG_CATALOG
              value: "off"
            # Others
            - name: POSTGRESQL_CLIENT_MIN_MESSAGES
              value: "error"
            - name: POSTGRESQL_SHARED_PRELOAD_LIBRARIES
              value: "pgaudit"
          ports:
            - name: tcp-postgresql
              containerPort: 5432  # Should match POSTGRESQL_PORT_NUMBER env var

          startupProbe:
            tcpSocket:
              port: 5432
            failureThreshold: 30
            periodSeconds: 10

          livenessProbe:
            tcpSocket:
              port: 5432
            failureThreshold: 6
            initialDelaySeconds: 30
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5

          readinessProbe:
            failureThreshold: 6
            initialDelaySeconds: 5
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
            exec:
              command:
                - /bin/sh
                - -c
                - -e
                - |
                  exec pg_isready -U "$POSTGRESQL_USERNAME" -d "dbname=$POSTGRESQL_DATABASE" -h 127.0.0.1 -p "$POSTGRESQL_PORT_NUMBER"
                  [ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]

          resources:
            limits:
              cpu: 500m
              memory: 512Mi
              ephemeral-storage: 1Gi
            requests:
              cpu: 250m
              memory: 256Mi
              ephemeral-storage: 500Mi
          volumeMounts:
            - name: dshm
              mountPath: /dev/shm
            - name: data
              mountPath: /bitnami/postgresql
            - name: initdb
              mountPath: /docker-entrypoint-initdb.d
              readOnly: true
      volumes:
        - name: dshm
          emptyDir:
            medium: Memory
        - name: initdb
          configMap:
            name: porch-db-schema
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: "5Gi"

---

apiVersion: v1
kind: Service
metadata:
  name: porch-postgresql
  namespace: porch-system
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: porch
    app.kubernetes.io/component: primary
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
    - name: postgresql
      port: 5432
      targetPort: tcp-postgresql
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: porch
    app.kubernetes.io/component: primary

---

apiVersion: v1
kind: Service
metadata:
  name: porch-postgresql-lb
  namespace: porch-system
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/part-of: porch
spec:
  type: LoadBalancer
  selector:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: porch
    app.kubernetes.io/component: primary
  ports:
    - name: postgresql
      port: 5432
      targetPort: 5432
      nodePort: 30002

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: porch-db-config
  namespace: porch-system
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: porch
data:
  DB_DRIVER: "pgx"
  DB_HOST: "porch-postgresql"
  DB_PORT: "5432"
  DB_NAME: "porch"

---

apiVersion: v1
kind: Secret
metadata:
  name: porch-db-secret
  namespace: porch-system
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: porch
type: Opaque
data:
  DB_USER: "cG9yY2g="
  DB_PASSWORD: "cG9yY2g="

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: porch-db-schema
  namespace: porch-system
data:
  porch-db.sql: |
    /*
    Copyright 2024-2025 The kpt and Nephio Authors

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    CREATE TABLE IF NOT EXISTS repositories (
        k8s_name_space  TEXT NOT NULL CHECK (k8s_name_space != ''),
        k8s_name        TEXT NOT NULL CHECK (k8s_name != ''),
        directory       TEXT NOT NULL,
        default_ws_name TEXT NOT NULL,
        meta            TEXT NOT NULL,
        spec            TEXT NOT NULL,
        updated         TIMESTAMP,
        updatedby       TEXT,
        deployment      BOOLEAN,
        PRIMARY KEY (k8s_name_space, k8s_name)
    );

    CREATE OR REPLACE FUNCTION check_immutable_repositories_columns() RETURNS trigger
        LANGUAGE plpgsql AS
    $BODY$
    BEGIN
        IF NEW.directory != OLD.directory OR NEW.default_ws_name != OLD.default_ws_name THEN
            RAISE EXCEPTION 'create or update not allowed on immutable columns "directory" and "default_ws_name"';
        END IF;
        RETURN NEW;
    END;
    $BODY$;

    CREATE OR REPLACE TRIGGER immutable_repositories_columns
       BEFORE UPDATE ON repositories FOR EACH ROW
       EXECUTE PROCEDURE check_immutable_repositories_columns();

    CREATE TABLE IF NOT EXISTS packages (
        k8s_name_space TEXT NOT NULL CHECK (k8s_name_space != ''),
        k8s_name       TEXT NOT NULL CHECK (k8s_name != ''),
        repo_k8s_name  TEXT NOT NULL,
        package_path   TEXT NOT NULL,
        meta           TEXT NOT NULL,
        spec           TEXT NOT NULL,
        updated        TIMESTAMP NOT NULL,
        updatedby      TEXT NOT NULL,
        PRIMARY KEY (k8s_name_space, k8s_name),
        CONSTRAINT fk_repository
            FOREIGN KEY (k8s_name_space, repo_k8s_name)
            REFERENCES repositories (k8s_name_space, k8s_name)
            ON DELETE CASCADE
    );

    CREATE OR REPLACE FUNCTION check_immutable_packages_columns() RETURNS trigger
        LANGUAGE plpgsql AS
    $BODY$
    BEGIN
        IF NEW.repo_k8s_name != OLD.repo_k8s_name OR NEW.package_path != OLD.package_path THEN
            RAISE EXCEPTION 'create or create or update not allowed on immutable columns "repo_k8s_name" and "package_path"';
        END IF;
        RETURN NEW;
    END;
    $BODY$;

    CREATE OR REPLACE TRIGGER immutable_packages_columns
       BEFORE UPDATE ON packages FOR EACH ROW
       EXECUTE PROCEDURE check_immutable_packages_columns();

    CREATE TABLE IF NOT EXISTS package_revisions (
        k8s_name_space   TEXT NOT NULL CHECK (k8s_name_space != ''),
        k8s_name         TEXT NOT NULL CHECK (k8s_name != ''),
        package_k8s_name TEXT NOT NULL,
        revision         INTEGER NOT NULL,
        meta             TEXT NOT NULL,
        spec             TEXT NOT NULL,
        updated          TIMESTAMP NOT NULL,
        updatedby        TEXT NOT NULL,
        lifecycle        TEXT CHECK (lifecycle IN ('Draft', 'Proposed', 'Published', 'DeletionProposed')) NOT NULL,
        ext_pr_id        TEXT NOT NULL,
        latest           BOOLEAN NOT NULL DEFAULT FALSE,
        tasks            TEXT NOT NULL,
        PRIMARY KEY (k8s_name_space, k8s_name),
        CONSTRAINT fk_package
            FOREIGN KEY (k8s_name_space, package_k8s_name)
            REFERENCES packages (k8s_name_space, k8s_name)
            ON DELETE CASCADE
    );

    CREATE OR REPLACE FUNCTION check_package_revisions_columns() RETURNS trigger
        LANGUAGE plpgsql AS
    $BODY$
    DECLARE
        lifecycle_draft             CONSTANT VARCHAR(5)  := 'Draft';
        lifecycle_proposed          CONSTANT VARCHAR(8)  := 'Proposed';
        lifecycle_published         CONSTANT VARCHAR(9)  := 'Published';
        lifecycle_deletion_proposed CONSTANT VARCHAR(16) := 'DeletionProposed';

        count_revisions INTEGER;
        latest_revision INTEGER;
    BEGIN
        IF NEW.package_k8s_name != OLD.package_k8s_name THEN
            RAISE EXCEPTION 'create or update not allowed on immutable column "package_k8s_name"';
        END IF;

        IF NEW.revision < -1 OR OLD.revision < -1 THEN
            RAISE EXCEPTION 'create or update not allowed on column "revision", revisions of less than -1 are not allowed';
        END IF;

        -- Package revisions in external repositories with uncontrolled revisions must always be 'Published' and cannot have lifecycle changes
        IF NEW.revision = -1 OR OLD.revision = -1 THEN
            IF NOT (NEW.lifecycle = lifecycle_published OR NEW.lifecycle = lifecycle_deletion_proposed) OR NOT (OLD.lifecycle = lifecycle_published OR OLD.lifecycle = lifecycle_deletion_proposed) THEN
                RAISE EXCEPTION 'create or update not allowed on column "lifecycle", lifecycle of % illegal, package revision has revision -1', NEW.lifecycle;
            ELSE
                return NEW;
            END IF;
        END IF;

        -- Package revisions with revision 0 are draft package revisions
        IF NEW.revision = 0 THEN
            IF OLD.revision != 0 THEN
                RAISE EXCEPTION 'create or update not allowed on column "revision", update of revision from % to zero is illegal', OLD.revision;
            END IF;

            IF NOT (NEW.lifecycle = lifecycle_draft OR NEW.lifecycle = lifecycle_proposed) OR NOT (OLD.lifecycle = lifecycle_draft OR OLD.lifecycle = lifecycle_proposed) THEN
                RAISE EXCEPTION 'create or update not allowed on column "revision", revision value of 0 is only allowed on when lifecycle is Draft or Proposed';
            END IF;

            return NEW;
        END IF;

        IF NEW.lifecycle = lifecycle_draft THEN
            RAISE EXCEPTION 'create or update not allowed on column "revision", revision of % on drafts is illegal', NEW.revision;
        END IF;

        IF NEW.revision = OLD.revision THEN
            IF NEW.lifecycle = OLD.lifecycle THEN
                return NEW;
            END IF;

            IF NEW.lifecycle = lifecycle_published OR NEW.lifecycle = lifecycle_deletion_proposed THEN
                return NEW;
            END IF;

            RAISE EXCEPTION 'create or update not allowed on column "lifecycle", change from % to % is illegal', OLD.lifecycle, NEW.lifecycle;
        END IF;

        IF OLD.revision != 0 THEN
            RAISE EXCEPTION 'create or update not allowed on column "revision", update of revision from % to % is illegal', OLD.revision, NEW.revision;
        END IF;

        IF OLD.lifecycle != lifecycle_proposed THEN
            RAISE EXCEPTION 'create or update not allowed on column "revision", lifecycle % is not Proposed', OLD.lifecycle;
        END IF;

        count_revisions := (SELECT COUNT(revision) FROM package_revisions WHERE k8s_name_space = NEW.k8s_name_space AND package_k8s_name = NEW.package_k8s_name AND revision = NEW.revision);
        IF count_revisions > 0 THEN
           RAISE EXCEPTION 'create or update not allowed on column "revision", revision % already exists', NEW.revision;
        END IF;

        latest_revision := (SELECT MAX(revision) FROM package_revisions WHERE k8s_name_space = NEW.k8s_name_space AND package_k8s_name = NEW.package_k8s_name AND revision > 0);

        IF NEW.lifecycle = lifecycle_published AND NEW.revision > 0 AND (latest_revision IS NULL OR NEW.revision >= latest_revision) THEN
            UPDATE package_revisions SET latest = FALSE WHERE k8s_name_space = NEW.k8s_name_space AND package_k8s_name = NEW.package_k8s_name AND latest;
            NEW.latest = TRUE;
        END IF;

        RETURN NEW;
    END;
    $BODY$;

    CREATE OR REPLACE TRIGGER package_revisions_columns
       BEFORE INSERT OR UPDATE ON package_revisions FOR EACH ROW
       EXECUTE PROCEDURE check_package_revisions_columns();

    CREATE OR REPLACE FUNCTION check_package_revisions_delete() RETURNS trigger
        LANGUAGE plpgsql AS
    $BODY$
    DECLARE
        lifecycle_published         CONSTANT VARCHAR(9)  := 'Published';
        lifecycle_deletion_proposed CONSTANT VARCHAR(16) := 'DeletionProposed';

        latest_revision INTEGER;
    BEGIN
        latest_revision := (SELECT MAX(revision) FROM package_revisions WHERE k8s_name_space = OLD.k8s_name_space AND package_k8s_name = OLD.package_k8s_name AND revision > 0);
        IF latest_revision IS NOT NULL THEN
            UPDATE package_revisions SET latest = TRUE WHERE k8s_name_space = OLD.k8s_name_space AND package_k8s_name = OLD.package_k8s_name AND revision = latest_revision AND (lifecycle = lifecycle_published OR lifecycle = lifecycle_deletion_proposed);
        END IF;
        RETURN OLD;
    END;
    $BODY$;

    CREATE OR REPLACE TRIGGER package_revisions_delete
       AFTER DELETE ON package_revisions FOR EACH ROW
       EXECUTE PROCEDURE check_package_revisions_delete();

    CREATE TABLE IF NOT EXISTS resources (
        k8s_name_space TEXT NOT NULL CHECK (k8s_name_space != ''),
        k8s_name       TEXT NOT NULL CHECK (k8s_name != ''),
        revision       INTEGER NOT NULL,
        resource_key   TEXT NOT NULL CHECK (resource_key != ''),
        resource_value TEXT NOT NULL,
        PRIMARY KEY (k8s_name_space, k8s_name, resource_key),
        CONSTRAINT fk_package_rev
            FOREIGN KEY (k8s_name_space, k8s_name)
            REFERENCES package_revisions (k8s_name_space, k8s_name)
            ON DELETE CASCADE
    );
