// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package engine

import (
	"context"

	"github.com/nephio-project/porch/api/porch"
	"github.com/nephio-project/porch/api/porchconfig/v1alpha1"
	"github.com/nephio-project/porch/pkg/engine"
	"github.com/nephio-project/porch/pkg/repository"
	mock "github.com/stretchr/testify/mock"
)

// NewMockCaDEngine creates a new instance of MockCaDEngine. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCaDEngine(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCaDEngine {
	mock := &MockCaDEngine{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCaDEngine is an autogenerated mock type for the CaDEngine type
type MockCaDEngine struct {
	mock.Mock
}

type MockCaDEngine_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCaDEngine) EXPECT() *MockCaDEngine_Expecter {
	return &MockCaDEngine_Expecter{mock: &_m.Mock}
}

// CreatePackage provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) CreatePackage(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porch.PorchPackage) (repository.Package, error) {
	ret := _mock.Called(ctx, repositoryObj, obj)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackage")
	}

	var r0 repository.Package
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porch.PorchPackage) (repository.Package, error)); ok {
		return returnFunc(ctx, repositoryObj, obj)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porch.PorchPackage) repository.Package); ok {
		r0 = returnFunc(ctx, repositoryObj, obj)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Package)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, *porch.PorchPackage) error); ok {
		r1 = returnFunc(ctx, repositoryObj, obj)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCaDEngine_CreatePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePackage'
type MockCaDEngine_CreatePackage_Call struct {
	*mock.Call
}

// CreatePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj *porch.PorchPackage
func (_e *MockCaDEngine_Expecter) CreatePackage(ctx interface{}, repositoryObj interface{}, obj interface{}) *MockCaDEngine_CreatePackage_Call {
	return &MockCaDEngine_CreatePackage_Call{Call: _e.mock.On("CreatePackage", ctx, repositoryObj, obj)}
}

func (_c *MockCaDEngine_CreatePackage_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porch.PorchPackage)) *MockCaDEngine_CreatePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 *porch.PorchPackage
		if args[2] != nil {
			arg2 = args[2].(*porch.PorchPackage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCaDEngine_CreatePackage_Call) Return(packageParam repository.Package, err error) *MockCaDEngine_CreatePackage_Call {
	_c.Call.Return(packageParam, err)
	return _c
}

func (_c *MockCaDEngine_CreatePackage_Call) RunAndReturn(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porch.PorchPackage) (repository.Package, error)) *MockCaDEngine_CreatePackage_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePackageRevision provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) CreatePackageRevision(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porch.PackageRevision, parent repository.PackageRevision) (repository.PackageRevision, error) {
	ret := _mock.Called(ctx, repositoryObj, obj, parent)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackageRevision")
	}

	var r0 repository.PackageRevision
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porch.PackageRevision, repository.PackageRevision) (repository.PackageRevision, error)); ok {
		return returnFunc(ctx, repositoryObj, obj, parent)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porch.PackageRevision, repository.PackageRevision) repository.PackageRevision); ok {
		r0 = returnFunc(ctx, repositoryObj, obj, parent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, *porch.PackageRevision, repository.PackageRevision) error); ok {
		r1 = returnFunc(ctx, repositoryObj, obj, parent)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCaDEngine_CreatePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePackageRevision'
type MockCaDEngine_CreatePackageRevision_Call struct {
	*mock.Call
}

// CreatePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj *porch.PackageRevision
//   - parent repository.PackageRevision
func (_e *MockCaDEngine_Expecter) CreatePackageRevision(ctx interface{}, repositoryObj interface{}, obj interface{}, parent interface{}) *MockCaDEngine_CreatePackageRevision_Call {
	return &MockCaDEngine_CreatePackageRevision_Call{Call: _e.mock.On("CreatePackageRevision", ctx, repositoryObj, obj, parent)}
}

func (_c *MockCaDEngine_CreatePackageRevision_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porch.PackageRevision, parent repository.PackageRevision)) *MockCaDEngine_CreatePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 *porch.PackageRevision
		if args[2] != nil {
			arg2 = args[2].(*porch.PackageRevision)
		}
		var arg3 repository.PackageRevision
		if args[3] != nil {
			arg3 = args[3].(repository.PackageRevision)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockCaDEngine_CreatePackageRevision_Call) Return(packageRevision repository.PackageRevision, err error) *MockCaDEngine_CreatePackageRevision_Call {
	_c.Call.Return(packageRevision, err)
	return _c
}

func (_c *MockCaDEngine_CreatePackageRevision_Call) RunAndReturn(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porch.PackageRevision, parent repository.PackageRevision) (repository.PackageRevision, error)) *MockCaDEngine_CreatePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePackage provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) DeletePackage(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.Package) error {
	ret := _mock.Called(ctx, repositoryObj, obj)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.Package) error); ok {
		r0 = returnFunc(ctx, repositoryObj, obj)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCaDEngine_DeletePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePackage'
type MockCaDEngine_DeletePackage_Call struct {
	*mock.Call
}

// DeletePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj repository.Package
func (_e *MockCaDEngine_Expecter) DeletePackage(ctx interface{}, repositoryObj interface{}, obj interface{}) *MockCaDEngine_DeletePackage_Call {
	return &MockCaDEngine_DeletePackage_Call{Call: _e.mock.On("DeletePackage", ctx, repositoryObj, obj)}
}

func (_c *MockCaDEngine_DeletePackage_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.Package)) *MockCaDEngine_DeletePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 repository.Package
		if args[2] != nil {
			arg2 = args[2].(repository.Package)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCaDEngine_DeletePackage_Call) Return(err error) *MockCaDEngine_DeletePackage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCaDEngine_DeletePackage_Call) RunAndReturn(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.Package) error) *MockCaDEngine_DeletePackage_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePackageRevision provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) DeletePackageRevision(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.PackageRevision) error {
	ret := _mock.Called(ctx, repositoryObj, obj)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackageRevision")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision) error); ok {
		r0 = returnFunc(ctx, repositoryObj, obj)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCaDEngine_DeletePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePackageRevision'
type MockCaDEngine_DeletePackageRevision_Call struct {
	*mock.Call
}

// DeletePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj repository.PackageRevision
func (_e *MockCaDEngine_Expecter) DeletePackageRevision(ctx interface{}, repositoryObj interface{}, obj interface{}) *MockCaDEngine_DeletePackageRevision_Call {
	return &MockCaDEngine_DeletePackageRevision_Call{Call: _e.mock.On("DeletePackageRevision", ctx, repositoryObj, obj)}
}

func (_c *MockCaDEngine_DeletePackageRevision_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.PackageRevision)) *MockCaDEngine_DeletePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 repository.PackageRevision
		if args[2] != nil {
			arg2 = args[2].(repository.PackageRevision)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCaDEngine_DeletePackageRevision_Call) Return(err error) *MockCaDEngine_DeletePackageRevision_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCaDEngine_DeletePackageRevision_Call) RunAndReturn(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.PackageRevision) error) *MockCaDEngine_DeletePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// ListPackageRevisions provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) ListPackageRevisions(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error) {
	ret := _mock.Called(ctx, repositorySpec, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageRevisions")
	}

	var r0 []repository.PackageRevision
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error)); ok {
		return returnFunc(ctx, repositorySpec, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) []repository.PackageRevision); ok {
		r0 = returnFunc(ctx, repositorySpec, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.PackageRevision)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) error); ok {
		r1 = returnFunc(ctx, repositorySpec, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCaDEngine_ListPackageRevisions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPackageRevisions'
type MockCaDEngine_ListPackageRevisions_Call struct {
	*mock.Call
}

// ListPackageRevisions is a helper method to define mock.On call
//   - ctx context.Context
//   - repositorySpec *v1alpha1.Repository
//   - filter repository.ListPackageRevisionFilter
func (_e *MockCaDEngine_Expecter) ListPackageRevisions(ctx interface{}, repositorySpec interface{}, filter interface{}) *MockCaDEngine_ListPackageRevisions_Call {
	return &MockCaDEngine_ListPackageRevisions_Call{Call: _e.mock.On("ListPackageRevisions", ctx, repositorySpec, filter)}
}

func (_c *MockCaDEngine_ListPackageRevisions_Call) Run(run func(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageRevisionFilter)) *MockCaDEngine_ListPackageRevisions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 repository.ListPackageRevisionFilter
		if args[2] != nil {
			arg2 = args[2].(repository.ListPackageRevisionFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCaDEngine_ListPackageRevisions_Call) Return(packageRevisions []repository.PackageRevision, err error) *MockCaDEngine_ListPackageRevisions_Call {
	_c.Call.Return(packageRevisions, err)
	return _c
}

func (_c *MockCaDEngine_ListPackageRevisions_Call) RunAndReturn(run func(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error)) *MockCaDEngine_ListPackageRevisions_Call {
	_c.Call.Return(run)
	return _c
}

// ListPackages provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) ListPackages(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageFilter) ([]repository.Package, error) {
	ret := _mock.Called(ctx, repositorySpec, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListPackages")
	}

	var r0 []repository.Package
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) ([]repository.Package, error)); ok {
		return returnFunc(ctx, repositorySpec, filter)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) []repository.Package); ok {
		r0 = returnFunc(ctx, repositorySpec, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.Package)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) error); ok {
		r1 = returnFunc(ctx, repositorySpec, filter)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCaDEngine_ListPackages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPackages'
type MockCaDEngine_ListPackages_Call struct {
	*mock.Call
}

// ListPackages is a helper method to define mock.On call
//   - ctx context.Context
//   - repositorySpec *v1alpha1.Repository
//   - filter repository.ListPackageFilter
func (_e *MockCaDEngine_Expecter) ListPackages(ctx interface{}, repositorySpec interface{}, filter interface{}) *MockCaDEngine_ListPackages_Call {
	return &MockCaDEngine_ListPackages_Call{Call: _e.mock.On("ListPackages", ctx, repositorySpec, filter)}
}

func (_c *MockCaDEngine_ListPackages_Call) Run(run func(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageFilter)) *MockCaDEngine_ListPackages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 repository.ListPackageFilter
		if args[2] != nil {
			arg2 = args[2].(repository.ListPackageFilter)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockCaDEngine_ListPackages_Call) Return(packages []repository.Package, err error) *MockCaDEngine_ListPackages_Call {
	_c.Call.Return(packages, err)
	return _c
}

func (_c *MockCaDEngine_ListPackages_Call) RunAndReturn(run func(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageFilter) ([]repository.Package, error)) *MockCaDEngine_ListPackages_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectCache provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) ObjectCache() engine.WatcherManager {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ObjectCache")
	}

	var r0 engine.WatcherManager
	if returnFunc, ok := ret.Get(0).(func() engine.WatcherManager); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(engine.WatcherManager)
		}
	}
	return r0
}

// MockCaDEngine_ObjectCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectCache'
type MockCaDEngine_ObjectCache_Call struct {
	*mock.Call
}

// ObjectCache is a helper method to define mock.On call
func (_e *MockCaDEngine_Expecter) ObjectCache() *MockCaDEngine_ObjectCache_Call {
	return &MockCaDEngine_ObjectCache_Call{Call: _e.mock.On("ObjectCache")}
}

func (_c *MockCaDEngine_ObjectCache_Call) Run(run func()) *MockCaDEngine_ObjectCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCaDEngine_ObjectCache_Call) Return(watcherManager engine.WatcherManager) *MockCaDEngine_ObjectCache_Call {
	_c.Call.Return(watcherManager)
	return _c
}

func (_c *MockCaDEngine_ObjectCache_Call) RunAndReturn(run func() engine.WatcherManager) *MockCaDEngine_ObjectCache_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackage provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) UpdatePackage(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.Package, old *porch.PorchPackage, new *porch.PorchPackage) (repository.Package, error) {
	ret := _mock.Called(ctx, repositoryObj, oldPackage, old, new)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackage")
	}

	var r0 repository.Package
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.Package, *porch.PorchPackage, *porch.PorchPackage) (repository.Package, error)); ok {
		return returnFunc(ctx, repositoryObj, oldPackage, old, new)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.Package, *porch.PorchPackage, *porch.PorchPackage) repository.Package); ok {
		r0 = returnFunc(ctx, repositoryObj, oldPackage, old, new)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Package)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.Package, *porch.PorchPackage, *porch.PorchPackage) error); ok {
		r1 = returnFunc(ctx, repositoryObj, oldPackage, old, new)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCaDEngine_UpdatePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackage'
type MockCaDEngine_UpdatePackage_Call struct {
	*mock.Call
}

// UpdatePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - oldPackage repository.Package
//   - old *porch.PorchPackage
//   - new *porch.PorchPackage
func (_e *MockCaDEngine_Expecter) UpdatePackage(ctx interface{}, repositoryObj interface{}, oldPackage interface{}, old interface{}, new interface{}) *MockCaDEngine_UpdatePackage_Call {
	return &MockCaDEngine_UpdatePackage_Call{Call: _e.mock.On("UpdatePackage", ctx, repositoryObj, oldPackage, old, new)}
}

func (_c *MockCaDEngine_UpdatePackage_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.Package, old *porch.PorchPackage, new *porch.PorchPackage)) *MockCaDEngine_UpdatePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 repository.Package
		if args[2] != nil {
			arg2 = args[2].(repository.Package)
		}
		var arg3 *porch.PorchPackage
		if args[3] != nil {
			arg3 = args[3].(*porch.PorchPackage)
		}
		var arg4 *porch.PorchPackage
		if args[4] != nil {
			arg4 = args[4].(*porch.PorchPackage)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockCaDEngine_UpdatePackage_Call) Return(packageParam repository.Package, err error) *MockCaDEngine_UpdatePackage_Call {
	_c.Call.Return(packageParam, err)
	return _c
}

func (_c *MockCaDEngine_UpdatePackage_Call) RunAndReturn(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.Package, old *porch.PorchPackage, new *porch.PorchPackage) (repository.Package, error)) *MockCaDEngine_UpdatePackage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackageResources provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) UpdatePackageResources(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porch.PackageRevisionResources, new *porch.PackageRevisionResources) (repository.PackageRevision, *porch.RenderStatus, error) {
	ret := _mock.Called(ctx, repositoryObj, oldPackage, old, new)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageResources")
	}

	var r0 repository.PackageRevision
	var r1 *porch.RenderStatus
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevisionResources, *porch.PackageRevisionResources) (repository.PackageRevision, *porch.RenderStatus, error)); ok {
		return returnFunc(ctx, repositoryObj, oldPackage, old, new)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevisionResources, *porch.PackageRevisionResources) repository.PackageRevision); ok {
		r0 = returnFunc(ctx, repositoryObj, oldPackage, old, new)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevisionResources, *porch.PackageRevisionResources) *porch.RenderStatus); ok {
		r1 = returnFunc(ctx, repositoryObj, oldPackage, old, new)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*porch.RenderStatus)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevisionResources, *porch.PackageRevisionResources) error); ok {
		r2 = returnFunc(ctx, repositoryObj, oldPackage, old, new)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockCaDEngine_UpdatePackageResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackageResources'
type MockCaDEngine_UpdatePackageResources_Call struct {
	*mock.Call
}

// UpdatePackageResources is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - oldPackage repository.PackageRevision
//   - old *porch.PackageRevisionResources
//   - new *porch.PackageRevisionResources
func (_e *MockCaDEngine_Expecter) UpdatePackageResources(ctx interface{}, repositoryObj interface{}, oldPackage interface{}, old interface{}, new interface{}) *MockCaDEngine_UpdatePackageResources_Call {
	return &MockCaDEngine_UpdatePackageResources_Call{Call: _e.mock.On("UpdatePackageResources", ctx, repositoryObj, oldPackage, old, new)}
}

func (_c *MockCaDEngine_UpdatePackageResources_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porch.PackageRevisionResources, new *porch.PackageRevisionResources)) *MockCaDEngine_UpdatePackageResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1alpha1.Repository
		if args[1] != nil {
			arg1 = args[1].(*v1alpha1.Repository)
		}
		var arg2 repository.PackageRevision
		if args[2] != nil {
			arg2 = args[2].(repository.PackageRevision)
		}
		var arg3 *porch.PackageRevisionResources
		if args[3] != nil {
			arg3 = args[3].(*porch.PackageRevisionResources)
		}
		var arg4 *porch.PackageRevisionResources
		if args[4] != nil {
			arg4 = args[4].(*porch.PackageRevisionResources)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockCaDEngine_UpdatePackageResources_Call) Return(packageRevision repository.PackageRevision, renderStatus *porch.RenderStatus, err error) *MockCaDEngine_UpdatePackageResources_Call {
	_c.Call.Return(packageRevision, renderStatus, err)
	return _c
}

func (_c *MockCaDEngine_UpdatePackageResources_Call) RunAndReturn(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porch.PackageRevisionResources, new *porch.PackageRevisionResources) (repository.PackageRevision, *porch.RenderStatus, error)) *MockCaDEngine_UpdatePackageResources_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackageRevision provides a mock function for the type MockCaDEngine
func (_mock *MockCaDEngine) UpdatePackageRevision(ctx context.Context, version int, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porch.PackageRevision, new *porch.PackageRevision, parent repository.PackageRevision) (repository.PackageRevision, error) {
	ret := _mock.Called(ctx, version, repositoryObj, oldPackage, old, new, parent)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageRevision")
	}

	var r0 repository.PackageRevision
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevision, *porch.PackageRevision, repository.PackageRevision) (repository.PackageRevision, error)); ok {
		return returnFunc(ctx, version, repositoryObj, oldPackage, old, new, parent)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevision, *porch.PackageRevision, repository.PackageRevision) repository.PackageRevision); ok {
		r0 = returnFunc(ctx, version, repositoryObj, oldPackage, old, new, parent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porch.PackageRevision, *porch.PackageRevision, repository.PackageRevision) error); ok {
		r1 = returnFunc(ctx, version, repositoryObj, oldPackage, old, new, parent)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCaDEngine_UpdatePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackageRevision'
type MockCaDEngine_UpdatePackageRevision_Call struct {
	*mock.Call
}

// UpdatePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - version int
//   - repositoryObj *v1alpha1.Repository
//   - oldPackage repository.PackageRevision
//   - old *porch.PackageRevision
//   - new *porch.PackageRevision
//   - parent repository.PackageRevision
func (_e *MockCaDEngine_Expecter) UpdatePackageRevision(ctx interface{}, version interface{}, repositoryObj interface{}, oldPackage interface{}, old interface{}, new interface{}, parent interface{}) *MockCaDEngine_UpdatePackageRevision_Call {
	return &MockCaDEngine_UpdatePackageRevision_Call{Call: _e.mock.On("UpdatePackageRevision", ctx, version, repositoryObj, oldPackage, old, new, parent)}
}

func (_c *MockCaDEngine_UpdatePackageRevision_Call) Run(run func(ctx context.Context, version int, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porch.PackageRevision, new *porch.PackageRevision, parent repository.PackageRevision)) *MockCaDEngine_UpdatePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 *v1alpha1.Repository
		if args[2] != nil {
			arg2 = args[2].(*v1alpha1.Repository)
		}
		var arg3 repository.PackageRevision
		if args[3] != nil {
			arg3 = args[3].(repository.PackageRevision)
		}
		var arg4 *porch.PackageRevision
		if args[4] != nil {
			arg4 = args[4].(*porch.PackageRevision)
		}
		var arg5 *porch.PackageRevision
		if args[5] != nil {
			arg5 = args[5].(*porch.PackageRevision)
		}
		var arg6 repository.PackageRevision
		if args[6] != nil {
			arg6 = args[6].(repository.PackageRevision)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
			arg5,
			arg6,
		)
	})
	return _c
}

func (_c *MockCaDEngine_UpdatePackageRevision_Call) Return(packageRevision repository.PackageRevision, err error) *MockCaDEngine_UpdatePackageRevision_Call {
	_c.Call.Return(packageRevision, err)
	return _c
}

func (_c *MockCaDEngine_UpdatePackageRevision_Call) RunAndReturn(run func(ctx context.Context, version int, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porch.PackageRevision, new *porch.PackageRevision, parent repository.PackageRevision) (repository.PackageRevision, error)) *MockCaDEngine_UpdatePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}
