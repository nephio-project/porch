// Code generated by mockery v2.53.3. DO NOT EDIT.

package engine

import (
	context "context"

	engine "github.com/nephio-project/porch/pkg/engine"
	mock "github.com/stretchr/testify/mock"

	porchv1alpha1 "github.com/nephio-project/porch/api/porch/v1alpha1"

	repository "github.com/nephio-project/porch/pkg/repository"

	v1alpha1 "github.com/nephio-project/porch/api/porchconfig/v1alpha1"
)

// MockCaDEngine is an autogenerated mock type for the CaDEngine type
type MockCaDEngine struct {
	mock.Mock
}

type MockCaDEngine_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCaDEngine) EXPECT() *MockCaDEngine_Expecter {
	return &MockCaDEngine_Expecter{mock: &_m.Mock}
}

// CreatePackage provides a mock function with given fields: ctx, repositoryObj, obj
func (_m *MockCaDEngine) CreatePackage(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porchv1alpha1.PorchPackage) (repository.Package, error) {
	ret := _m.Called(ctx, repositoryObj, obj)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackage")
	}

	var r0 repository.Package
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PorchPackage) (repository.Package, error)); ok {
		return rf(ctx, repositoryObj, obj)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PorchPackage) repository.Package); ok {
		r0 = rf(ctx, repositoryObj, obj)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Package)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PorchPackage) error); ok {
		r1 = rf(ctx, repositoryObj, obj)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCaDEngine_CreatePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePackage'
type MockCaDEngine_CreatePackage_Call struct {
	*mock.Call
}

// CreatePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj *porchv1alpha1.PorchPackage
func (_e *MockCaDEngine_Expecter) CreatePackage(ctx interface{}, repositoryObj interface{}, obj interface{}) *MockCaDEngine_CreatePackage_Call {
	return &MockCaDEngine_CreatePackage_Call{Call: _e.mock.On("CreatePackage", ctx, repositoryObj, obj)}
}

func (_c *MockCaDEngine_CreatePackage_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porchv1alpha1.PorchPackage)) *MockCaDEngine_CreatePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(*porchv1alpha1.PorchPackage))
	})
	return _c
}

func (_c *MockCaDEngine_CreatePackage_Call) Return(_a0 repository.Package, _a1 error) *MockCaDEngine_CreatePackage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCaDEngine_CreatePackage_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PorchPackage) (repository.Package, error)) *MockCaDEngine_CreatePackage_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePackageRevision provides a mock function with given fields: ctx, repositoryObj, obj, parent
func (_m *MockCaDEngine) CreatePackageRevision(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porchv1alpha1.PackageRevision, parent repository.PackageRevision) (repository.PackageRevision, error) {
	ret := _m.Called(ctx, repositoryObj, obj, parent)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackageRevision")
	}

	var r0 repository.PackageRevision
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PackageRevision, repository.PackageRevision) (repository.PackageRevision, error)); ok {
		return rf(ctx, repositoryObj, obj, parent)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PackageRevision, repository.PackageRevision) repository.PackageRevision); ok {
		r0 = rf(ctx, repositoryObj, obj, parent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PackageRevision, repository.PackageRevision) error); ok {
		r1 = rf(ctx, repositoryObj, obj, parent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCaDEngine_CreatePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePackageRevision'
type MockCaDEngine_CreatePackageRevision_Call struct {
	*mock.Call
}

// CreatePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj *porchv1alpha1.PackageRevision
//   - parent repository.PackageRevision
func (_e *MockCaDEngine_Expecter) CreatePackageRevision(ctx interface{}, repositoryObj interface{}, obj interface{}, parent interface{}) *MockCaDEngine_CreatePackageRevision_Call {
	return &MockCaDEngine_CreatePackageRevision_Call{Call: _e.mock.On("CreatePackageRevision", ctx, repositoryObj, obj, parent)}
}

func (_c *MockCaDEngine_CreatePackageRevision_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj *porchv1alpha1.PackageRevision, parent repository.PackageRevision)) *MockCaDEngine_CreatePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(*porchv1alpha1.PackageRevision), args[3].(repository.PackageRevision))
	})
	return _c
}

func (_c *MockCaDEngine_CreatePackageRevision_Call) Return(_a0 repository.PackageRevision, _a1 error) *MockCaDEngine_CreatePackageRevision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCaDEngine_CreatePackageRevision_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, *porchv1alpha1.PackageRevision, repository.PackageRevision) (repository.PackageRevision, error)) *MockCaDEngine_CreatePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePackage provides a mock function with given fields: ctx, repositoryObj, obj
func (_m *MockCaDEngine) DeletePackage(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.Package) error {
	ret := _m.Called(ctx, repositoryObj, obj)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.Package) error); ok {
		r0 = rf(ctx, repositoryObj, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCaDEngine_DeletePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePackage'
type MockCaDEngine_DeletePackage_Call struct {
	*mock.Call
}

// DeletePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj repository.Package
func (_e *MockCaDEngine_Expecter) DeletePackage(ctx interface{}, repositoryObj interface{}, obj interface{}) *MockCaDEngine_DeletePackage_Call {
	return &MockCaDEngine_DeletePackage_Call{Call: _e.mock.On("DeletePackage", ctx, repositoryObj, obj)}
}

func (_c *MockCaDEngine_DeletePackage_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.Package)) *MockCaDEngine_DeletePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(repository.Package))
	})
	return _c
}

func (_c *MockCaDEngine_DeletePackage_Call) Return(_a0 error) *MockCaDEngine_DeletePackage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCaDEngine_DeletePackage_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, repository.Package) error) *MockCaDEngine_DeletePackage_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePackageRevision provides a mock function with given fields: ctx, repositoryObj, obj
func (_m *MockCaDEngine) DeletePackageRevision(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.PackageRevision) error {
	ret := _m.Called(ctx, repositoryObj, obj)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackageRevision")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision) error); ok {
		r0 = rf(ctx, repositoryObj, obj)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockCaDEngine_DeletePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePackageRevision'
type MockCaDEngine_DeletePackageRevision_Call struct {
	*mock.Call
}

// DeletePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - obj repository.PackageRevision
func (_e *MockCaDEngine_Expecter) DeletePackageRevision(ctx interface{}, repositoryObj interface{}, obj interface{}) *MockCaDEngine_DeletePackageRevision_Call {
	return &MockCaDEngine_DeletePackageRevision_Call{Call: _e.mock.On("DeletePackageRevision", ctx, repositoryObj, obj)}
}

func (_c *MockCaDEngine_DeletePackageRevision_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, obj repository.PackageRevision)) *MockCaDEngine_DeletePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(repository.PackageRevision))
	})
	return _c
}

func (_c *MockCaDEngine_DeletePackageRevision_Call) Return(_a0 error) *MockCaDEngine_DeletePackageRevision_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCaDEngine_DeletePackageRevision_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, repository.PackageRevision) error) *MockCaDEngine_DeletePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// ListPackageRevisions provides a mock function with given fields: ctx, repositorySpec, filter
func (_m *MockCaDEngine) ListPackageRevisions(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error) {
	ret := _m.Called(ctx, repositorySpec, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageRevisions")
	}

	var r0 []repository.PackageRevision
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error)); ok {
		return rf(ctx, repositorySpec, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) []repository.PackageRevision); ok {
		r0 = rf(ctx, repositorySpec, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.PackageRevision)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) error); ok {
		r1 = rf(ctx, repositorySpec, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCaDEngine_ListPackageRevisions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPackageRevisions'
type MockCaDEngine_ListPackageRevisions_Call struct {
	*mock.Call
}

// ListPackageRevisions is a helper method to define mock.On call
//   - ctx context.Context
//   - repositorySpec *v1alpha1.Repository
//   - filter repository.ListPackageRevisionFilter
func (_e *MockCaDEngine_Expecter) ListPackageRevisions(ctx interface{}, repositorySpec interface{}, filter interface{}) *MockCaDEngine_ListPackageRevisions_Call {
	return &MockCaDEngine_ListPackageRevisions_Call{Call: _e.mock.On("ListPackageRevisions", ctx, repositorySpec, filter)}
}

func (_c *MockCaDEngine_ListPackageRevisions_Call) Run(run func(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageRevisionFilter)) *MockCaDEngine_ListPackageRevisions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(repository.ListPackageRevisionFilter))
	})
	return _c
}

func (_c *MockCaDEngine_ListPackageRevisions_Call) Return(_a0 []repository.PackageRevision, _a1 error) *MockCaDEngine_ListPackageRevisions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCaDEngine_ListPackageRevisions_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error)) *MockCaDEngine_ListPackageRevisions_Call {
	_c.Call.Return(run)
	return _c
}

// ListPackages provides a mock function with given fields: ctx, repositorySpec, filter
func (_m *MockCaDEngine) ListPackages(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageFilter) ([]repository.Package, error) {
	ret := _m.Called(ctx, repositorySpec, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListPackages")
	}

	var r0 []repository.Package
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) ([]repository.Package, error)); ok {
		return rf(ctx, repositorySpec, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) []repository.Package); ok {
		r0 = rf(ctx, repositorySpec, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.Package)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) error); ok {
		r1 = rf(ctx, repositorySpec, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCaDEngine_ListPackages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPackages'
type MockCaDEngine_ListPackages_Call struct {
	*mock.Call
}

// ListPackages is a helper method to define mock.On call
//   - ctx context.Context
//   - repositorySpec *v1alpha1.Repository
//   - filter repository.ListPackageFilter
func (_e *MockCaDEngine_Expecter) ListPackages(ctx interface{}, repositorySpec interface{}, filter interface{}) *MockCaDEngine_ListPackages_Call {
	return &MockCaDEngine_ListPackages_Call{Call: _e.mock.On("ListPackages", ctx, repositorySpec, filter)}
}

func (_c *MockCaDEngine_ListPackages_Call) Run(run func(ctx context.Context, repositorySpec *v1alpha1.Repository, filter repository.ListPackageFilter)) *MockCaDEngine_ListPackages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(repository.ListPackageFilter))
	})
	return _c
}

func (_c *MockCaDEngine_ListPackages_Call) Return(_a0 []repository.Package, _a1 error) *MockCaDEngine_ListPackages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCaDEngine_ListPackages_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, repository.ListPackageFilter) ([]repository.Package, error)) *MockCaDEngine_ListPackages_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectCache provides a mock function with no fields
func (_m *MockCaDEngine) ObjectCache() engine.WatcherManager {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ObjectCache")
	}

	var r0 engine.WatcherManager
	if rf, ok := ret.Get(0).(func() engine.WatcherManager); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(engine.WatcherManager)
		}
	}

	return r0
}

// MockCaDEngine_ObjectCache_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectCache'
type MockCaDEngine_ObjectCache_Call struct {
	*mock.Call
}

// ObjectCache is a helper method to define mock.On call
func (_e *MockCaDEngine_Expecter) ObjectCache() *MockCaDEngine_ObjectCache_Call {
	return &MockCaDEngine_ObjectCache_Call{Call: _e.mock.On("ObjectCache")}
}

func (_c *MockCaDEngine_ObjectCache_Call) Run(run func()) *MockCaDEngine_ObjectCache_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCaDEngine_ObjectCache_Call) Return(_a0 engine.WatcherManager) *MockCaDEngine_ObjectCache_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockCaDEngine_ObjectCache_Call) RunAndReturn(run func() engine.WatcherManager) *MockCaDEngine_ObjectCache_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackage provides a mock function with given fields: ctx, repositoryObj, oldPackage, old, new
func (_m *MockCaDEngine) UpdatePackage(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.Package, old *porchv1alpha1.PorchPackage, new *porchv1alpha1.PorchPackage) (repository.Package, error) {
	ret := _m.Called(ctx, repositoryObj, oldPackage, old, new)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackage")
	}

	var r0 repository.Package
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.Package, *porchv1alpha1.PorchPackage, *porchv1alpha1.PorchPackage) (repository.Package, error)); ok {
		return rf(ctx, repositoryObj, oldPackage, old, new)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.Package, *porchv1alpha1.PorchPackage, *porchv1alpha1.PorchPackage) repository.Package); ok {
		r0 = rf(ctx, repositoryObj, oldPackage, old, new)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Package)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.Package, *porchv1alpha1.PorchPackage, *porchv1alpha1.PorchPackage) error); ok {
		r1 = rf(ctx, repositoryObj, oldPackage, old, new)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCaDEngine_UpdatePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackage'
type MockCaDEngine_UpdatePackage_Call struct {
	*mock.Call
}

// UpdatePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - oldPackage repository.Package
//   - old *porchv1alpha1.PorchPackage
//   - new *porchv1alpha1.PorchPackage
func (_e *MockCaDEngine_Expecter) UpdatePackage(ctx interface{}, repositoryObj interface{}, oldPackage interface{}, old interface{}, new interface{}) *MockCaDEngine_UpdatePackage_Call {
	return &MockCaDEngine_UpdatePackage_Call{Call: _e.mock.On("UpdatePackage", ctx, repositoryObj, oldPackage, old, new)}
}

func (_c *MockCaDEngine_UpdatePackage_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.Package, old *porchv1alpha1.PorchPackage, new *porchv1alpha1.PorchPackage)) *MockCaDEngine_UpdatePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(repository.Package), args[3].(*porchv1alpha1.PorchPackage), args[4].(*porchv1alpha1.PorchPackage))
	})
	return _c
}

func (_c *MockCaDEngine_UpdatePackage_Call) Return(_a0 repository.Package, _a1 error) *MockCaDEngine_UpdatePackage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCaDEngine_UpdatePackage_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, repository.Package, *porchv1alpha1.PorchPackage, *porchv1alpha1.PorchPackage) (repository.Package, error)) *MockCaDEngine_UpdatePackage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackageResources provides a mock function with given fields: ctx, repositoryObj, oldPackage, old, new
func (_m *MockCaDEngine) UpdatePackageResources(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porchv1alpha1.PackageRevisionResources, new *porchv1alpha1.PackageRevisionResources) (repository.PackageRevision, *porchv1alpha1.RenderStatus, error) {
	ret := _m.Called(ctx, repositoryObj, oldPackage, old, new)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageResources")
	}

	var r0 repository.PackageRevision
	var r1 *porchv1alpha1.RenderStatus
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevisionResources, *porchv1alpha1.PackageRevisionResources) (repository.PackageRevision, *porchv1alpha1.RenderStatus, error)); ok {
		return rf(ctx, repositoryObj, oldPackage, old, new)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevisionResources, *porchv1alpha1.PackageRevisionResources) repository.PackageRevision); ok {
		r0 = rf(ctx, repositoryObj, oldPackage, old, new)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevisionResources, *porchv1alpha1.PackageRevisionResources) *porchv1alpha1.RenderStatus); ok {
		r1 = rf(ctx, repositoryObj, oldPackage, old, new)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*porchv1alpha1.RenderStatus)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevisionResources, *porchv1alpha1.PackageRevisionResources) error); ok {
		r2 = rf(ctx, repositoryObj, oldPackage, old, new)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockCaDEngine_UpdatePackageResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackageResources'
type MockCaDEngine_UpdatePackageResources_Call struct {
	*mock.Call
}

// UpdatePackageResources is a helper method to define mock.On call
//   - ctx context.Context
//   - repositoryObj *v1alpha1.Repository
//   - oldPackage repository.PackageRevision
//   - old *porchv1alpha1.PackageRevisionResources
//   - new *porchv1alpha1.PackageRevisionResources
func (_e *MockCaDEngine_Expecter) UpdatePackageResources(ctx interface{}, repositoryObj interface{}, oldPackage interface{}, old interface{}, new interface{}) *MockCaDEngine_UpdatePackageResources_Call {
	return &MockCaDEngine_UpdatePackageResources_Call{Call: _e.mock.On("UpdatePackageResources", ctx, repositoryObj, oldPackage, old, new)}
}

func (_c *MockCaDEngine_UpdatePackageResources_Call) Run(run func(ctx context.Context, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porchv1alpha1.PackageRevisionResources, new *porchv1alpha1.PackageRevisionResources)) *MockCaDEngine_UpdatePackageResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.Repository), args[2].(repository.PackageRevision), args[3].(*porchv1alpha1.PackageRevisionResources), args[4].(*porchv1alpha1.PackageRevisionResources))
	})
	return _c
}

func (_c *MockCaDEngine_UpdatePackageResources_Call) Return(_a0 repository.PackageRevision, _a1 *porchv1alpha1.RenderStatus, _a2 error) *MockCaDEngine_UpdatePackageResources_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockCaDEngine_UpdatePackageResources_Call) RunAndReturn(run func(context.Context, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevisionResources, *porchv1alpha1.PackageRevisionResources) (repository.PackageRevision, *porchv1alpha1.RenderStatus, error)) *MockCaDEngine_UpdatePackageResources_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackageRevision provides a mock function with given fields: ctx, version, repositoryObj, oldPackage, old, new, parent
func (_m *MockCaDEngine) UpdatePackageRevision(ctx context.Context, version int, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porchv1alpha1.PackageRevision, new *porchv1alpha1.PackageRevision, parent repository.PackageRevision) (repository.PackageRevision, error) {
	ret := _m.Called(ctx, version, repositoryObj, oldPackage, old, new, parent)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageRevision")
	}

	var r0 repository.PackageRevision
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevision, *porchv1alpha1.PackageRevision, repository.PackageRevision) (repository.PackageRevision, error)); ok {
		return rf(ctx, version, repositoryObj, oldPackage, old, new, parent)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevision, *porchv1alpha1.PackageRevision, repository.PackageRevision) repository.PackageRevision); ok {
		r0 = rf(ctx, version, repositoryObj, oldPackage, old, new, parent)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevision, *porchv1alpha1.PackageRevision, repository.PackageRevision) error); ok {
		r1 = rf(ctx, version, repositoryObj, oldPackage, old, new, parent)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockCaDEngine_UpdatePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackageRevision'
type MockCaDEngine_UpdatePackageRevision_Call struct {
	*mock.Call
}

// UpdatePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - version int
//   - repositoryObj *v1alpha1.Repository
//   - oldPackage repository.PackageRevision
//   - old *porchv1alpha1.PackageRevision
//   - new *porchv1alpha1.PackageRevision
//   - parent repository.PackageRevision
func (_e *MockCaDEngine_Expecter) UpdatePackageRevision(ctx interface{}, version interface{}, repositoryObj interface{}, oldPackage interface{}, old interface{}, new interface{}, parent interface{}) *MockCaDEngine_UpdatePackageRevision_Call {
	return &MockCaDEngine_UpdatePackageRevision_Call{Call: _e.mock.On("UpdatePackageRevision", ctx, version, repositoryObj, oldPackage, old, new, parent)}
}

func (_c *MockCaDEngine_UpdatePackageRevision_Call) Run(run func(ctx context.Context, version int, repositoryObj *v1alpha1.Repository, oldPackage repository.PackageRevision, old *porchv1alpha1.PackageRevision, new *porchv1alpha1.PackageRevision, parent repository.PackageRevision)) *MockCaDEngine_UpdatePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*v1alpha1.Repository), args[3].(repository.PackageRevision), args[4].(*porchv1alpha1.PackageRevision), args[5].(*porchv1alpha1.PackageRevision), args[6].(repository.PackageRevision))
	})
	return _c
}

func (_c *MockCaDEngine_UpdatePackageRevision_Call) Return(_a0 repository.PackageRevision, _a1 error) *MockCaDEngine_UpdatePackageRevision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockCaDEngine_UpdatePackageRevision_Call) RunAndReturn(run func(context.Context, int, *v1alpha1.Repository, repository.PackageRevision, *porchv1alpha1.PackageRevision, *porchv1alpha1.PackageRevision, repository.PackageRevision) (repository.PackageRevision, error)) *MockCaDEngine_UpdatePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCaDEngine creates a new instance of MockCaDEngine. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCaDEngine(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCaDEngine {
	mock := &MockCaDEngine{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
