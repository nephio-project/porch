// Code generated by mockery v2.53.3. DO NOT EDIT.

package repository

import (
	context "context"

	repository "github.com/nephio-project/porch/pkg/repository"
	mock "github.com/stretchr/testify/mock"

	v1alpha1 "github.com/nephio-project/porch/api/porch/v1alpha1"
)

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with given fields: ctx
func (_m *MockRepository) Close(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockRepository_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) Close(ctx interface{}) *MockRepository_Close_Call {
	return &MockRepository_Close_Call{Call: _e.mock.On("Close", ctx)}
}

func (_c *MockRepository_Close_Call) Run(run func(ctx context.Context)) *MockRepository_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_Close_Call) Return(_a0 error) *MockRepository_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_Close_Call) RunAndReturn(run func(context.Context) error) *MockRepository_Close_Call {
	_c.Call.Return(run)
	return _c
}

// ClosePackageRevisionDraft provides a mock function with given fields: ctx, prd, version
func (_m *MockRepository) ClosePackageRevisionDraft(ctx context.Context, prd repository.PackageRevisionDraft, version int) (repository.PackageRevision, error) {
	ret := _m.Called(ctx, prd, version)

	if len(ret) == 0 {
		panic("no return value specified for ClosePackageRevisionDraft")
	}

	var r0 repository.PackageRevision
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.PackageRevisionDraft, int) (repository.PackageRevision, error)); ok {
		return rf(ctx, prd, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.PackageRevisionDraft, int) repository.PackageRevision); ok {
		r0 = rf(ctx, prd, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevision)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.PackageRevisionDraft, int) error); ok {
		r1 = rf(ctx, prd, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_ClosePackageRevisionDraft_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClosePackageRevisionDraft'
type MockRepository_ClosePackageRevisionDraft_Call struct {
	*mock.Call
}

// ClosePackageRevisionDraft is a helper method to define mock.On call
//   - ctx context.Context
//   - prd repository.PackageRevisionDraft
//   - version int
func (_e *MockRepository_Expecter) ClosePackageRevisionDraft(ctx interface{}, prd interface{}, version interface{}) *MockRepository_ClosePackageRevisionDraft_Call {
	return &MockRepository_ClosePackageRevisionDraft_Call{Call: _e.mock.On("ClosePackageRevisionDraft", ctx, prd, version)}
}

func (_c *MockRepository_ClosePackageRevisionDraft_Call) Run(run func(ctx context.Context, prd repository.PackageRevisionDraft, version int)) *MockRepository_ClosePackageRevisionDraft_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.PackageRevisionDraft), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_ClosePackageRevisionDraft_Call) Return(_a0 repository.PackageRevision, _a1 error) *MockRepository_ClosePackageRevisionDraft_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_ClosePackageRevisionDraft_Call) RunAndReturn(run func(context.Context, repository.PackageRevisionDraft, int) (repository.PackageRevision, error)) *MockRepository_ClosePackageRevisionDraft_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePackage provides a mock function with given fields: ctx, obj
func (_m *MockRepository) CreatePackage(ctx context.Context, obj *v1alpha1.PorchPackage) (repository.Package, error) {
	ret := _m.Called(ctx, obj)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackage")
	}

	var r0 repository.Package
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.PorchPackage) (repository.Package, error)); ok {
		return rf(ctx, obj)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.PorchPackage) repository.Package); ok {
		r0 = rf(ctx, obj)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Package)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.PorchPackage) error); ok {
		r1 = rf(ctx, obj)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_CreatePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePackage'
type MockRepository_CreatePackage_Call struct {
	*mock.Call
}

// CreatePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - obj *v1alpha1.PorchPackage
func (_e *MockRepository_Expecter) CreatePackage(ctx interface{}, obj interface{}) *MockRepository_CreatePackage_Call {
	return &MockRepository_CreatePackage_Call{Call: _e.mock.On("CreatePackage", ctx, obj)}
}

func (_c *MockRepository_CreatePackage_Call) Run(run func(ctx context.Context, obj *v1alpha1.PorchPackage)) *MockRepository_CreatePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.PorchPackage))
	})
	return _c
}

func (_c *MockRepository_CreatePackage_Call) Return(_a0 repository.Package, _a1 error) *MockRepository_CreatePackage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_CreatePackage_Call) RunAndReturn(run func(context.Context, *v1alpha1.PorchPackage) (repository.Package, error)) *MockRepository_CreatePackage_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePackageRevisionDraft provides a mock function with given fields: ctx, obj
func (_m *MockRepository) CreatePackageRevisionDraft(ctx context.Context, obj *v1alpha1.PackageRevision) (repository.PackageRevisionDraft, error) {
	ret := _m.Called(ctx, obj)

	if len(ret) == 0 {
		panic("no return value specified for CreatePackageRevisionDraft")
	}

	var r0 repository.PackageRevisionDraft
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.PackageRevision) (repository.PackageRevisionDraft, error)); ok {
		return rf(ctx, obj)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.PackageRevision) repository.PackageRevisionDraft); ok {
		r0 = rf(ctx, obj)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevisionDraft)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1alpha1.PackageRevision) error); ok {
		r1 = rf(ctx, obj)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_CreatePackageRevisionDraft_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePackageRevisionDraft'
type MockRepository_CreatePackageRevisionDraft_Call struct {
	*mock.Call
}

// CreatePackageRevisionDraft is a helper method to define mock.On call
//   - ctx context.Context
//   - obj *v1alpha1.PackageRevision
func (_e *MockRepository_Expecter) CreatePackageRevisionDraft(ctx interface{}, obj interface{}) *MockRepository_CreatePackageRevisionDraft_Call {
	return &MockRepository_CreatePackageRevisionDraft_Call{Call: _e.mock.On("CreatePackageRevisionDraft", ctx, obj)}
}

func (_c *MockRepository_CreatePackageRevisionDraft_Call) Run(run func(ctx context.Context, obj *v1alpha1.PackageRevision)) *MockRepository_CreatePackageRevisionDraft_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*v1alpha1.PackageRevision))
	})
	return _c
}

func (_c *MockRepository_CreatePackageRevisionDraft_Call) Return(_a0 repository.PackageRevisionDraft, _a1 error) *MockRepository_CreatePackageRevisionDraft_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_CreatePackageRevisionDraft_Call) RunAndReturn(run func(context.Context, *v1alpha1.PackageRevision) (repository.PackageRevisionDraft, error)) *MockRepository_CreatePackageRevisionDraft_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePackage provides a mock function with given fields: ctx, old
func (_m *MockRepository) DeletePackage(ctx context.Context, old repository.Package) error {
	ret := _m.Called(ctx, old)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.Package) error); ok {
		r0 = rf(ctx, old)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeletePackage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePackage'
type MockRepository_DeletePackage_Call struct {
	*mock.Call
}

// DeletePackage is a helper method to define mock.On call
//   - ctx context.Context
//   - old repository.Package
func (_e *MockRepository_Expecter) DeletePackage(ctx interface{}, old interface{}) *MockRepository_DeletePackage_Call {
	return &MockRepository_DeletePackage_Call{Call: _e.mock.On("DeletePackage", ctx, old)}
}

func (_c *MockRepository_DeletePackage_Call) Run(run func(ctx context.Context, old repository.Package)) *MockRepository_DeletePackage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.Package))
	})
	return _c
}

func (_c *MockRepository_DeletePackage_Call) Return(_a0 error) *MockRepository_DeletePackage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeletePackage_Call) RunAndReturn(run func(context.Context, repository.Package) error) *MockRepository_DeletePackage_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePackageRevision provides a mock function with given fields: ctx, old
func (_m *MockRepository) DeletePackageRevision(ctx context.Context, old repository.PackageRevision) error {
	ret := _m.Called(ctx, old)

	if len(ret) == 0 {
		panic("no return value specified for DeletePackageRevision")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.PackageRevision) error); ok {
		r0 = rf(ctx, old)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_DeletePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePackageRevision'
type MockRepository_DeletePackageRevision_Call struct {
	*mock.Call
}

// DeletePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - old repository.PackageRevision
func (_e *MockRepository_Expecter) DeletePackageRevision(ctx interface{}, old interface{}) *MockRepository_DeletePackageRevision_Call {
	return &MockRepository_DeletePackageRevision_Call{Call: _e.mock.On("DeletePackageRevision", ctx, old)}
}

func (_c *MockRepository_DeletePackageRevision_Call) Run(run func(ctx context.Context, old repository.PackageRevision)) *MockRepository_DeletePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.PackageRevision))
	})
	return _c
}

func (_c *MockRepository_DeletePackageRevision_Call) Return(_a0 error) *MockRepository_DeletePackageRevision_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_DeletePackageRevision_Call) RunAndReturn(run func(context.Context, repository.PackageRevision) error) *MockRepository_DeletePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// Key provides a mock function with no fields
func (_m *MockRepository) Key() repository.RepositoryKey {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Key")
	}

	var r0 repository.RepositoryKey
	if rf, ok := ret.Get(0).(func() repository.RepositoryKey); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(repository.RepositoryKey)
	}

	return r0
}

// MockRepository_Key_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Key'
type MockRepository_Key_Call struct {
	*mock.Call
}

// Key is a helper method to define mock.On call
func (_e *MockRepository_Expecter) Key() *MockRepository_Key_Call {
	return &MockRepository_Key_Call{Call: _e.mock.On("Key")}
}

func (_c *MockRepository_Key_Call) Run(run func()) *MockRepository_Key_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRepository_Key_Call) Return(_a0 repository.RepositoryKey) *MockRepository_Key_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_Key_Call) RunAndReturn(run func() repository.RepositoryKey) *MockRepository_Key_Call {
	_c.Call.Return(run)
	return _c
}

// KubeObjectName provides a mock function with no fields
func (_m *MockRepository) KubeObjectName() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for KubeObjectName")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockRepository_KubeObjectName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KubeObjectName'
type MockRepository_KubeObjectName_Call struct {
	*mock.Call
}

// KubeObjectName is a helper method to define mock.On call
func (_e *MockRepository_Expecter) KubeObjectName() *MockRepository_KubeObjectName_Call {
	return &MockRepository_KubeObjectName_Call{Call: _e.mock.On("KubeObjectName")}
}

func (_c *MockRepository_KubeObjectName_Call) Run(run func()) *MockRepository_KubeObjectName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRepository_KubeObjectName_Call) Return(_a0 string) *MockRepository_KubeObjectName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_KubeObjectName_Call) RunAndReturn(run func() string) *MockRepository_KubeObjectName_Call {
	_c.Call.Return(run)
	return _c
}

// KubeObjectNamespace provides a mock function with no fields
func (_m *MockRepository) KubeObjectNamespace() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for KubeObjectNamespace")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockRepository_KubeObjectNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KubeObjectNamespace'
type MockRepository_KubeObjectNamespace_Call struct {
	*mock.Call
}

// KubeObjectNamespace is a helper method to define mock.On call
func (_e *MockRepository_Expecter) KubeObjectNamespace() *MockRepository_KubeObjectNamespace_Call {
	return &MockRepository_KubeObjectNamespace_Call{Call: _e.mock.On("KubeObjectNamespace")}
}

func (_c *MockRepository_KubeObjectNamespace_Call) Run(run func()) *MockRepository_KubeObjectNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRepository_KubeObjectNamespace_Call) Return(_a0 string) *MockRepository_KubeObjectNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_KubeObjectNamespace_Call) RunAndReturn(run func() string) *MockRepository_KubeObjectNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// ListPackageRevisions provides a mock function with given fields: ctx, filter
func (_m *MockRepository) ListPackageRevisions(ctx context.Context, filter repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListPackageRevisions")
	}

	var r0 []repository.PackageRevision
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.ListPackageRevisionFilter) []repository.PackageRevision); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.PackageRevision)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.ListPackageRevisionFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_ListPackageRevisions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPackageRevisions'
type MockRepository_ListPackageRevisions_Call struct {
	*mock.Call
}

// ListPackageRevisions is a helper method to define mock.On call
//   - ctx context.Context
//   - filter repository.ListPackageRevisionFilter
func (_e *MockRepository_Expecter) ListPackageRevisions(ctx interface{}, filter interface{}) *MockRepository_ListPackageRevisions_Call {
	return &MockRepository_ListPackageRevisions_Call{Call: _e.mock.On("ListPackageRevisions", ctx, filter)}
}

func (_c *MockRepository_ListPackageRevisions_Call) Run(run func(ctx context.Context, filter repository.ListPackageRevisionFilter)) *MockRepository_ListPackageRevisions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.ListPackageRevisionFilter))
	})
	return _c
}

func (_c *MockRepository_ListPackageRevisions_Call) Return(_a0 []repository.PackageRevision, _a1 error) *MockRepository_ListPackageRevisions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_ListPackageRevisions_Call) RunAndReturn(run func(context.Context, repository.ListPackageRevisionFilter) ([]repository.PackageRevision, error)) *MockRepository_ListPackageRevisions_Call {
	_c.Call.Return(run)
	return _c
}

// ListPackages provides a mock function with given fields: ctx, filter
func (_m *MockRepository) ListPackages(ctx context.Context, filter repository.ListPackageFilter) ([]repository.Package, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for ListPackages")
	}

	var r0 []repository.Package
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.ListPackageFilter) ([]repository.Package, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.ListPackageFilter) []repository.Package); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.Package)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.ListPackageFilter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_ListPackages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPackages'
type MockRepository_ListPackages_Call struct {
	*mock.Call
}

// ListPackages is a helper method to define mock.On call
//   - ctx context.Context
//   - filter repository.ListPackageFilter
func (_e *MockRepository_Expecter) ListPackages(ctx interface{}, filter interface{}) *MockRepository_ListPackages_Call {
	return &MockRepository_ListPackages_Call{Call: _e.mock.On("ListPackages", ctx, filter)}
}

func (_c *MockRepository_ListPackages_Call) Run(run func(ctx context.Context, filter repository.ListPackageFilter)) *MockRepository_ListPackages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.ListPackageFilter))
	})
	return _c
}

func (_c *MockRepository_ListPackages_Call) Return(_a0 []repository.Package, _a1 error) *MockRepository_ListPackages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_ListPackages_Call) RunAndReturn(run func(context.Context, repository.ListPackageFilter) ([]repository.Package, error)) *MockRepository_ListPackages_Call {
	_c.Call.Return(run)
	return _c
}

// Refresh provides a mock function with given fields: ctx
func (_m *MockRepository) Refresh(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Refresh")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_Refresh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Refresh'
type MockRepository_Refresh_Call struct {
	*mock.Call
}

// Refresh is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) Refresh(ctx interface{}) *MockRepository_Refresh_Call {
	return &MockRepository_Refresh_Call{Call: _e.mock.On("Refresh", ctx)}
}

func (_c *MockRepository_Refresh_Call) Run(run func(ctx context.Context)) *MockRepository_Refresh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_Refresh_Call) Return(_a0 error) *MockRepository_Refresh_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_Refresh_Call) RunAndReturn(run func(context.Context) error) *MockRepository_Refresh_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePackageRevision provides a mock function with given fields: ctx, old
func (_m *MockRepository) UpdatePackageRevision(ctx context.Context, old repository.PackageRevision) (repository.PackageRevisionDraft, error) {
	ret := _m.Called(ctx, old)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePackageRevision")
	}

	var r0 repository.PackageRevisionDraft
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.PackageRevision) (repository.PackageRevisionDraft, error)); ok {
		return rf(ctx, old)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.PackageRevision) repository.PackageRevisionDraft); ok {
		r0 = rf(ctx, old)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.PackageRevisionDraft)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.PackageRevision) error); ok {
		r1 = rf(ctx, old)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_UpdatePackageRevision_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePackageRevision'
type MockRepository_UpdatePackageRevision_Call struct {
	*mock.Call
}

// UpdatePackageRevision is a helper method to define mock.On call
//   - ctx context.Context
//   - old repository.PackageRevision
func (_e *MockRepository_Expecter) UpdatePackageRevision(ctx interface{}, old interface{}) *MockRepository_UpdatePackageRevision_Call {
	return &MockRepository_UpdatePackageRevision_Call{Call: _e.mock.On("UpdatePackageRevision", ctx, old)}
}

func (_c *MockRepository_UpdatePackageRevision_Call) Run(run func(ctx context.Context, old repository.PackageRevision)) *MockRepository_UpdatePackageRevision_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.PackageRevision))
	})
	return _c
}

func (_c *MockRepository_UpdatePackageRevision_Call) Return(_a0 repository.PackageRevisionDraft, _a1 error) *MockRepository_UpdatePackageRevision_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_UpdatePackageRevision_Call) RunAndReturn(run func(context.Context, repository.PackageRevision) (repository.PackageRevisionDraft, error)) *MockRepository_UpdatePackageRevision_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function with given fields: ctx
func (_m *MockRepository) Version(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type MockRepository_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) Version(ctx interface{}) *MockRepository_Version_Call {
	return &MockRepository_Version_Call{Call: _e.mock.On("Version", ctx)}
}

func (_c *MockRepository_Version_Call) Run(run func(ctx context.Context)) *MockRepository_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_Version_Call) Return(_a0 string, _a1 error) *MockRepository_Version_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_Version_Call) RunAndReturn(run func(context.Context) (string, error)) *MockRepository_Version_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
